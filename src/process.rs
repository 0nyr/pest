// pest. Elegant, efficient grammars
// Copyright (C) 2016  Drago»ô Tiselice
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/// A `macro` for pattern-matching queued `Token`s generated by a `Parser`. It generates a method
/// `process` on `&self` that processes the whole queue of `Token`s, reducing it to one single
/// result. The type of this result is specified at the beginning of the definition.
///
/// The `process` is populated with methods that match patterns, and the way a pattern shall be
/// dealt with. A pattern is constructed from the following comma-separated items:
///
/// | Item        | What it does                                       |
/// |-------------|----------------------------------------------------|
/// | `item`      | matches any `Token`                                |
/// | `item: R`   | matches a `Token` of rule `R`                      |
/// | `&item`     | captures a `Token`                                 |
/// | `&item: R`  | captures a `Token` of rule `R`                     |
/// | `_`         | skips a `Token`                                    |
/// | `_: R`      | skips a `Token` of rule `R`                        |
/// | `@item`     | call method recursively and store result in `item` |
/// | `@<fn>item` | call `fn` and store result in `item`               |
///
/// `process` automatically calls the `main` matcher which is mandatory.
///
/// # Panics
///
/// In case all the patterns inside of `process!` won't match, the `process` method will `panic!`.
///
/// ```should_panic
/// # #[macro_use] extern crate pest;
/// # use pest::prelude::*;
/// # fn main() {
/// impl_rdp! {
///     grammar! {
///         a = { ["a"] }
///         b = { ["b"] }
///     }
///
///     process! {
///         main(&self) -> () {
///             (_: a) => {}
///         }
///     }
/// }
///
/// let mut parser = Rdp::new(StringInput::new("b"));
///
/// parser.b();
/// parser.process();
/// # }
/// ```
///
/// # Examples
///
/// ### Nested letter
///
/// Let's consider the following grammar of nested letters:
///
/// ```no_run
/// # #[macro_use] extern crate pest;
/// # use pest::prelude::*;
/// # fn main() {
/// # impl_rdp! {
/// # grammar! {
/// expression = _{ paren | letter } // we don't need the expression Token
/// paren      =  { ["("] ~ expression ~ [")"] }
/// letter     =  { ['a'..'z'] }
/// # }
/// # }
/// # unreachable!();
/// # }
/// ```
///
/// Defining the grammar paves way to a simple data-structre (an `enum`) that can be either a
/// `Paren` or a `Letter`.
///
/// ```no_run
/// #[derive(Debug, PartialEq)]
/// pub enum Expression {
///     Paren(Box<Expression>),
///     Letter(char)
/// }
/// ```
///
/// The processing phase needs to handle two cases: parens and letters. Letters are
/// straightforward captures:
///
/// ```ignore
/// (&letter: letter)
/// ```
///
/// Parens need to recursively process the next item in order to be stored inside of the `Paren`.
/// But before that, it needs to match a `paren` `Token` that gets ignored.
///
/// ```ignore
/// (_: paren, @expression)
/// ```
///
/// All together now:
///
/// ```
/// # #[macro_use] extern crate pest;
/// # use pest::prelude::*;
/// # fn main() {
/// #[derive(Debug, PartialEq)]
/// pub enum Expression {
///     Paren(Box<Expression>),
///     Letter(char)
/// }
///
/// impl_rdp! {
///     grammar! {
///         expression = _{ paren | letter }
///         paren      =  { ["("] ~ expression ~ [")"] }
///         letter     =  { ['a'..'z'] }
///     }
///
///     process! {
///         main(&self) -> Expression {
///             (&letter: letter) => {
///                 Expression::Letter(letter.chars().next().unwrap())
///             },
///             (_: paren, @expression) => {
///                 Expression::Paren(Box::new(expression))
///             }
///         }
///     }
/// }
///
/// let mut parser = Rdp::new(StringInput::new("((z))"));
///
/// assert!(parser.expression());
/// assert_eq!(parser.process(),
///            Expression::Paren(Box::new(Expression::Paren(Box::new(Expression::Letter('z'))))));
/// # }
/// ```
///
/// ### Sentence
///
/// To showcase the use of multiple matchers, we'll use a sentence grammar:
///
/// ```no_run
/// # #[macro_use] extern crate pest;
/// # use pest::prelude::*;
/// # fn main() {
/// # impl_rdp! {
/// # grammar! {
/// sentence = { word ~ ([" "] ~ word)* }
/// word     = { letter* }
/// letter   = { ['a'..'z'] }
/// # }
/// # }
/// # unreachable!();
/// # }
/// ```
///
/// Let's create a very simple AST that works in this case:
///
/// ```no_run
/// # use std::collections::LinkedList;
/// #[derive(Debug, PartialEq)]
/// pub enum Node {
///     Sentence(LinkedList<Node>), // we're using LinkedList because they're more efficient when
///     Word(LinkedList<Node>),     // using tail recursion
///     Letter(char)
/// }
/// ```
///
/// To build the `Token` processor, let's use a bottom up aproach when writing the matchers. Let's
/// start by building a `word` matcher. We'll call it `_word` in order not to clash with the name
/// of the rule that also gets defined as a method on the `Parser`.
///
/// ```ignore
/// _word(&self) -> LinkedList<Node> { // return LinkedList<Node> to build Word with
///     (&head: letter, @tail) => { // usual tail recursion; &head is captured,
///         let mut tail = tail;    // tail is recursive
///         tail.push_front(Node::Letter(head.chars().next().unwrap()));
///
///         tail
///     },
///     () => {                // if rule above doesn't match, there are no more letters to
///         LinkedList::new()  // process; return empty list
///     }
/// }
/// ```
///
/// Processing a `sentence` is similar, only this time `head` will be a `_word` call.
///
/// ```ignore
/// _sentence(&self) -> LinkedList<Node> {
///     (_: word, @<_word>head, @tail) => { // match word Token then call _word
///         let mut tail = tail;
///         tail.push_front(Node::Word(head));
///
///         tail
///     },
///     () => {
///         LinkedList::new()
///     }
/// }
/// ```
///
/// Finally, the `main` matcher:
///
/// ```ignore
/// main(&self) -> Node {
///     (_: sentence, @<_sentence>list) => {
///         Node::Sentence(list)
///     }
/// }
/// ```
///
/// Putting everything together:
///
/// ```
/// # #[macro_use] extern crate pest;
/// # use std::collections::LinkedList;
/// # use pest::prelude::*;
/// # fn main() {
/// #[derive(Debug, PartialEq)]
/// pub enum Node {
///     Sentence(LinkedList<Node>),
///     Word(LinkedList<Node>),
///     Letter(char)
/// }
///
/// impl_rdp! {
///     grammar! {
///         sentence = { word ~ ([" "] ~ word)* }
///         word     = { letter* }
///         letter   = { ['a'..'z'] }
///     }
///
///     process! {
///         main(&self) -> Node {
///             (_: sentence, @<_sentence>list) => {
///                 Node::Sentence(list)
///             }
///         }
///
///         _sentence(&self) -> LinkedList<Node> {
///             (_: word, @<_word>head, @tail) => {
///                 let mut tail = tail;
///                 tail.push_front(Node::Word(head));
///
///                 tail
///             },
///             () => {
///                 LinkedList::new()
///             }
///         }
///
///         _word(&self) -> LinkedList<Node> {
///             (&head: letter, @tail) => {
///                 let mut tail = tail;
///                 tail.push_front(Node::Letter(head.chars().next().unwrap()));
///
///                 tail
///             },
///             () => {
///                 LinkedList::new()
///             }
///         }
///     }
/// }
///
/// let mut parser = Rdp::new(StringInput::new("abc def"));
///
/// assert!(parser.sentence());
/// parser.process();
/// # }
/// ```
#[macro_export]
macro_rules! process {
    // handle patterns; increment $index automatically
    // _ : rule
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) _ : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) _ : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $index = $index + 1;

                    process!(@pattern $slf $index $name ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // _
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) _ ) => {
        {
            let $index = $index + 1;

            Some(($block, $index))
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) _, $( $tail:tt )* ) => {
        {
            let $index = $index + 1;

            process!(@pattern $slf $index $name ($block) $( $tail )*)
        }
    };
    // &name : rule
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) &$head:ident : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.slice_input(token.start, token.end);

                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) &$head:ident : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.slice_input(token.start, token.end);

                    let $index = $index + 1;

                    process!(@pattern $slf $index $name ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // &name
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) &$head:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = $slf.slice_input(token.start, token.end);

                let $index = $index + 1;

                Some(($block, $index))
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) &$head:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = $slf.slice_input(token.start, token.end);

                let $index = $index + 1;

                process!(@pattern $slf $index $name ($block) $( $tail )*)
            } else {
                None
            }
        }
    };
    // @<fun>recurse
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) @<$fun:ident>$head:ident ) => {
        {
            let ($head, index) = $slf.$fun($index);
            let $index = index;

            Some(($block, $index))
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) @<$fun:ident>$head:ident,
      $( $tail:tt )* ) => {
        {
            let ($head, index) = $slf.$fun($index);
            let $index = index;

            process!(@pattern $slf $index $name ($block) $( $tail )*)
        }
    };
    // @recurse
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) @$head:ident ) => {
        {
            let ($head, index) = $slf.$name($index);
            let $index = index;

            Some(($block, $index))
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) @$head:ident, $( $tail:tt )* ) => {
        {
            let ($head, index) = $slf.$name($index);
            let $index = index;

            process!(@pattern $slf $index $name ($block) $( $tail )*)
        }
    };
    // name : rule
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) $head:ident : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];

                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) $head:ident : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];

                    let $index = $index + 1;

                    process!(@pattern $slf $index $name ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // name
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) $head:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;

                let $index = $index + 1;

                Some(($block, $index))
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) $head:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;

                let $index = $index + 1;

                process!(@pattern $slf $index $name ($block) $( $tail )*)
            } else {
                None
            }
        }
    };
    // empty
    ( @pattern $slf:ident $index:ident $name:ident ($block:expr) ) => {
        {
            Some(($block, $index))
        }
    };

    // handle branches; panic if no branch matches
    ( @branches $slf:ident $index:ident $name:ident ( $( $pattern:tt )* ) => $block:expr) => {
        if let Some(result) = process!(@pattern $slf $index $name ($block) $( $pattern )*) {
            result
        } else {
            panic!("no rules matched in {}", stringify!($name))
        }
    };
    ( @branches $slf:ident $index:ident $name:ident ( $( $pattern:tt )* ) => $block:expr,) => {
        if let Some(result) = process!(@pattern $slf $index $name ($block) $( $pattern )*) {
            result
        } else {
            panic!("no rules matched in {}", stringify!($name))
        }
    };
    ( @branches $slf:ident $index:ident $name:ident ( $( $pattern:tt )* ) => $block:expr, $( $tail:tt )* ) => {
        if let Some(result) = process!(@pattern $slf $index $name ($block) $( $pattern )*) {
            result
        } else {
            process!(@branches $slf $index $name $( $tail )*)
        }
    };

    // get main's type
    ( @type (main $typ:ty) $( $_ts:tt )* ) => {
        pub fn process(&self) -> $typ {
            self.main(0).0
        }
    };
    ( @type ($_name:ident $_typ:ty) $( $ts:tt )* ) => {
        process!(@type $( $ts )*);
    };

    ( $( $name:ident (&$slf:ident) -> $typ:ty { $( $ts:tt )* } )* ) => {
        $(
            fn $name(&$slf, index: usize) -> ($typ, usize) {
                process!(@branches $slf index $name $( $ts )*)
            }
        )*

        process!(@type $( ($name $typ) )*);
    }
}
