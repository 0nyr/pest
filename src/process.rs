// pest. Smart PEGs in Rust
// Copyright (C) 2016  Drago»ô Tiselice
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

/// A `macro` for pattern-matching queued `Token`s generated by a `Parser`. It generates a method
/// `process` on `&self` that processes the whole queue of `Token`s, reducing it to one single
/// result. The type of this result is specified at the beginning of the definition.
///
/// The `process` is populated with patterns and the way a pattern shall be dealt with. A pattern
/// is constructed from the following comma-separated items:
///
/// | Item       | What it does                   |
/// |------------|--------------------------------|
/// | `item`     | matches any `Token`            |
/// | `item: R`  | matches a `Token` of rule `R`  |
/// | `&item`    | captures a `Token`             |
/// | `&item: R` | captures a `Token` of rule `R` |
/// | `_`        | skips a `Token`                |
/// | `_: R`     | skips a `Token` of rule `R`    |
/// | `@item`    | recursively process child      |
///
/// # Examples
///
/// ### Nested letter
///
/// Let's consider the following grammar of nested letters:
///
/// ```no_run
/// # #[macro_use] extern crate pest;
/// # use pest::Parser;
/// # use pest::Token;
/// # use pest::Input;
/// # use pest::StringInput;
/// # fn main() {
/// # impl_rdp! {
/// # grammar! {
/// exp    = _{ paren | letter }      // exp is quiet since we already know what we're parsing
/// paren  =  { ["("] ~ exp ~ [")"] }
/// letter =  { ['a'..'z'] }
/// # }
/// # }
/// # unreachable!();
/// # }
/// ```
///
/// Defining the grammar paves way to a simple data-structre (an `enum`) that can be either a
/// `Paren` or a `Letter`.
///
/// ```no_run
/// #[derive(Debug, PartialEq)]
/// pub enum Exp {
///     Paren(Box<Exp>),
///     Letter(char)
/// }
/// ```
///
/// The processing phase needs to handle two cases: parens and letters. Letters are
/// straightforward captures:
///
/// ```ignore
/// (&letter: letter)
/// ```
///
/// Parens need to recursively process the next item in order to be stored inside of the `Paren`.
/// But before that, it needs to match a `paren` `Token` that gets ignored.
///
/// ```ignore
/// (_: paren, @exp)
/// ```
///
/// All together now:
///
/// ```
/// # #[macro_use] extern crate pest;
/// # use pest::Parser;
/// # use pest::Token;
/// # use pest::Input;
/// # use pest::StringInput;
/// # fn main() {
/// #[derive(Debug, PartialEq)]
/// pub enum Exp {
///     Paren(Box<Exp>),
///     Letter(char)
/// }
///
/// impl_rdp! {
///     grammar! {
///         exp    = _{ paren | letter }
///         paren  =  { ["("] ~ exp ~ [")"] }
///         letter =  { ['a'..'z'] }
///     }
///
///     process! {
///         (&self) -> Exp {
///             (&letter: letter) => {
///                 Exp::Letter(letter.chars().next().unwrap())
///             },
///             (_: paren, @exp) => {
///                 Exp::Paren(Box::new(exp))
///             }
///         }
///     }
/// }
///
/// let mut parser = Rdp::new(StringInput::new("((z))"));
///
/// assert!(parser.exp());
/// assert_eq!(parser.process(), Exp::Paren(Box::new(Exp::Paren(Box::new(Exp::Letter('z'))))));
/// # }
/// ```
#[macro_export]
macro_rules! process {
    // handle patterns; increment $index automatically
    // _ : rule
    ( @pattern $slf:ident $index:ident ($block:expr) _ : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) _ : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $index = $index + 1;

                    process!(@pattern $slf $index ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // _
    ( @pattern $slf:ident $index:ident ($block:expr) _ ) => {
        {
            let $index = $index + 1;

            Some(($block, $index))
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) _, $( $tail:tt )* ) => {
        {
            let $index = $index + 1;

            process!(@pattern $slf $index ($block) $( $tail )*)
        }
    };
    // &name : rule
    ( @pattern $slf:ident $index:ident ($block:expr) &$head:ident : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];
                    let $head = $slf.slice_input($head.start, $head.end);

                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) &$head:ident : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];
                    let $head = $slf.slice_input($head.start, $head.end);

                    let $index = $index + 1;

                    process!(@pattern $slf $index ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // &name
    ( @pattern $slf:ident $index:ident ($block:expr) &$head:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;
                let $head = $slf.slice_input($head.start, $head.end);

                let $index = $index + 1;

                Some(($block, $index))
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) &$head:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;
                let $head = $slf.slice_input($head.start, $head.end);

                let $index = $index + 1;

                process!(@pattern $slf $index ($block) $( $tail )*)
            } else {
                None
            }
        }
    };
    // @recurse
    ( @pattern $slf:ident $index:ident ($block:expr) @$head:ident ) => {
        {
            let ($head, index) = $slf.next($index);
            let $index = index;

            Some(($block, $index))
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) @$head:ident, $( $tail:tt )* ) => {
        {
            let ($head, index) = $slf.next($index);
            let $index = index;

            process!(@pattern $slf $index ($block) $( $tail )*)
        }
    };
    // name : rule
    ( @pattern $slf:ident $index:ident ($block:expr) $head:ident : $typ:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];

                    let $index = $index + 1;

                    Some(($block, $index))
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) $head:ident : $typ:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                if token.rule == Rule::$typ {
                    let $head = $slf.queue()[$index];

                    let $index = $index + 1;

                    process!(@pattern $slf $index ($block) $( $tail )*)
                } else {
                    None
                }
            } else {
                None
            }
        }
    };
    // name
    ( @pattern $slf:ident $index:ident ($block:expr) $head:ident ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;

                let $index = $index + 1;

                Some(($block, $index))
            } else {
                None
            }
        }
    };
    ( @pattern $slf:ident $index:ident ($block:expr) $head:ident, $( $tail:tt )* ) => {
        {
            if let Some(token) = $slf.queue().get($index) {
                let $head = token;

                let $index = $index + 1;

                process!(@pattern $slf $index ($block) $( $tail )*)
            } else {
                None
            }
        }
    };

    // handle branches; panic if no branch matches
    ( @branches $slf:ident $index:ident ( $( $pattern:tt )* ) => $block:expr) => {
        if let Some(result) = process!(@pattern $slf $index ($block) $( $pattern )*) {
            result
        } else {
            panic!("no rules matched")
        }
    };
    ( @branches $slf:ident $index:ident ( $( $pattern:tt )* ) => $block:expr,) => {
        if let Some(result) = process!(@pattern $slf $index ($block) $( $pattern )*) {
            result
        } else {
            panic!("no rules matched")
        }
    };
    ( @branches $slf:ident $index:ident ( $( $pattern:tt )* ) => $block:expr, $( $tail:tt )* ) => {
        if let Some(result) = process!(@pattern $slf $index ($block) $( $pattern )*) {
            result
        } else {
            process!(@branches $slf $index $( $tail )*)
        }
    };

    ( (&$slf:ident) -> $typ:ty { $( $ts:tt )* } ) => {
        fn next(&$slf, index: usize) -> ($typ, usize) {
            process!(@branches $slf index $( $ts )*)
        }

        pub fn process(&self) -> $typ {
            self.next(0).0
        }
    }
}
